% Dstar 不太适用于 找到 AStar周边的路径 因此编写遍历周边所有的网格来找到障碍物% 输入1：路径 Q (M x 3)% 输入2：新观测到的障碍物地图 ObservedMap% 输入3：周边路径半径 R  (M x N x 3) % 输入4：最小路径单元 DX (M x N x 3)% 输出1：Q 对应的 P 障碍物% 输出2：V 对应的 V 障碍物对应的路径向量function [P, V] = FindObstacleVectorDstar(Q, ObservedMap, R, Dx)    if nargin == 2        R = 2; Dx = 1;    end    % 运行找到地图定义    map_define;    % 检测地图大小    sx = size(ObservedMap, 1);    sy = size(ObservedMap, 2);    sz = size(ObservedMap, 3);        % 初值    P = {};    V = {};    %    /|\%     |%     |%     |  /|---/|%     | / |  / |%     |o--o-|o-|o--o%    o #############\%  o #|   | |  |######o--o--o%     |_ /|_|_/|######________________\%    /|/  | /  |                      /%   / | /---|-/%  /  |/____|/   动态检测障碍物%|/_            sQ = size(Q, 1);    % 路径大小    range = fix(R / Dx);    for qq = 1:sQ        sQx = Q(qq, 1); sQy = Q(qq, 2); sQz = Q(qq, 3);        % 路径点        qP = []; qV = [];        % 这里假设路径都不存在直接通过障碍物的情况        for xx = -range:range            for yy = -range:range                 for zz = -range:range                    mapQx = fix(xx + sQx); mapQy = fix(yy + sQy); mapQz = fix(zz + sQz);                    if mapQx <= 0 || mapQy <= 0 || mapQz <= 0 || ...                            mapQx > sx || mapQy > sy || mapQz > sz                        continue;                        % 超出地图范围                    end                    % 自己的节点不算                    if xx == 0 && yy == 0 && zz == 0, continue; end                                        % ...                    if ObservedMap(mapQx, mapQy, mapQz) == obstacle                        qP = [qP; mapQx mapQy mapQz];                        v  = [xx yy zz] / norm([xx yy zz]);                        qV = [qV; v];                    end                end            end        end        P{qq} = qP;         V{qq} = qV;        % 加载值    endend